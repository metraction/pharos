# yaml-language-server: $schema=./values.schema.json

image:
  # -- registry for pharos-image
  registry: ghcr.io
  # -- repository for pharos-image
  repository: metraction/pharos
  # -- pull policy for pharos-image
  pullPolicy: Always

# -- list of imagePullSecrets to use. These secrets are also used to get the images to scan.
imagePullSecrets: []
  # - name: github-registry

ingress:
  # -- Enable ingress for pharos
  enabled: false
  # host: "pharos.my-domain.com"
  # className: nginx
  # tls: true
  # tlsSecretName: "pharos-tls"
  # annotations:
  #   cert-manager.io/cluster-issuer: letsencrypt-prod
  #   kubernetes.io/ingress.class: nginx
  #   kubernetes.io/tls-acme: 'true'
  #   nginx.ingress.kubernetes.io/client-body-buffer-size: 400M
  #   nginx.ingress.kubernetes.io/proxy-body-size: 8G
  #   nginx.org/client-max-body-size: 8G   

service:
  # -- port for the service
  port: 8080

redis:
  # -- Enable Redis deployment
  enabled: true
  # -- Redis authentication
  auth: false
  # -- Redis replica configuration
  replicas: 3
  persistentVolume:
    size: 2Gi

scannerPod:
  # -- Enable the scanner pod, only neeed if you are not using direct scan
  enabled: false

priorityScannerPod:
  # -- Enable the scanner pod, only needed if you are not using direct scan
  enabled: false

externalDatabase:
  # -- Existing Secret containing dsn for an external database, set this if postgres.enabled=false must contain dsn: "postgres://username:password@hostname:5432/dbname?sslmode=disable"
  secret: "postgres-connection"

# -- PostgreSQL configuration
postgres:
  enabled: true
  image:
    registry: "docker.io"
    repository: "postgres"
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: "17.6"
  # -- Enable PostgreSQL deployment
  dataDir: "/var/lib/postgresql/data"
  pgDir: "pg"
  serviceAccount:
    # Specifies whether a service account should be created
    create: false
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""
  # -- PostgreSQL startup probe configuration
  startupProbe:
    enabled: true
    initialDelaySeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
    successThreshold: 1
    periodSeconds: 10
  # -- PostgreSQL liveness probe configuration  
  livenessProbe:
    enabled: true
    initialDelaySeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
    periodSeconds: 10
  # -- PostgreSQL readiness probe configuration  
  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
    periodSeconds: 10
  # -- PostgreSQL resources 
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  # -- PostgreSQL persistence storage configuration  
  storage:
    ## Internal volume name and prefix of a created PVC
    volumeName: "postgres-data"
    ## Alternative set requestedSize to define a size for a dynmaically created PVC
    requestedSize: 1Gi
    ## the storage class name
    className:
    ## Default access mode (ReadWriteOnce)
    accessModes:
      - ReadWriteOnce
    ## Keep a created Persistent volume claim when uninstalling the helm chart (only for option useDeployment: true)
    keepPvc: false
    ## Additional storage annotations
    annotations: {}
    ## Additional storage labels
    labels: {}
  ## Pod management policy
  podManagementPolicy: OrderedReady
  ## Pod update strategy
  updateStrategyType: RollingUpdate

  ## Pod security context uses file system group 999 (postgres)
  podSecurityContext:
    fsGroup: 999
    supplementalGroups:
      - 999

  ## Default security options to run PostgreSQL as non-root (postgres user), read only container without privilege escalation
  securityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsGroup: 999
    runAsUser: 999
    capabilities:
      drop:
        - ALL
  ## The postgres service configuration (Default is ClusterIP with port 5432)
  service:
    type: ClusterIP
    port: 5432
    ## The node port (only relevant for type LoadBalancer or NodePort)
    nodePort:
    ## The cluster ip address (only relevant for type LoadBalancer or NodePort)
    clusterIP:
    ## The loadbalancer ip address (only relevant for type LoadBalancer)
    loadBalancerIP:
    ## The list of IP CIDR ranges that are allowed to access the load balancer (only relevent for type LoadBalancer)
    loadBalancerSourceRanges: []
    ## Annotations to add to the service
    annotations: {}
    ## Labels to add to the service
    labels: {}
  # -- PostgreSQL authentication
  auth:
    # -- Use an existing secret for PostgreSQL connection
    #existingSecret: "postgres-connection"
    postgresPassword: "pharos"
    username: "pharos"
    password: "pharos"
    database: "pharos"
    # secretKeys:
    #   adminPasswordKey: ""
    #   userPasswordKey: ""

# -- External Redis configuration (used when redis.enabled=false)
externalRedis:
  host: "localhost"
  port: 6379

# -- Service account configuration - needed to read ImagePullSecrets
serviceAccount:
  create: true

# -- Role configuration - needed to read ImagePullSecrets
role:
  create: true

controller:
  # -- Number of replicas for the controller
  replicas: 1
  collector:
    # -- Queue size for the collector
    queueSize: 100
  publisher:
    # -- Queue size for the publisher
    queueSize: 1000  

# -- Prometheus configuration for scanning images
prometheus:
  # -- Url of the Prometheus server
  url: "http://prometheus.prometheus.svc.cluster.local:9090"
  # -- Prometheus query to get the images to scan
  query: 'kube_pod_container_info{}'
  # -- Interval for scanning images
  interval: 10m
  # -- Context labels to add to the Prometheus context
  contextLabels: "namespace"
  # -- Time to live for the scan results, defaults to 12 hours
  ttl: "12h"
  # -- Authentication for Prometheus
  auth:
    # -- Username for Prometheus authentication
    username: ""
    # -- Password for Prometheus authentication
    password: ""
    # -- Token for Prometheus authentication
    token: ""
  authFromSecret:
    # -- Enable authentication from an existing secret
    enabled: false
    # -- Use an existing secret for Prometheus authentication
    existingSecret: ""
    # -- Key in the secret for the username
    usernameKey: "username"
    # -- Key in the secret for the password
    passwordKey: "password"
    # -- Key in the secret for the token
    tokenKey: ""

# -- Enrichers configuration
enrichers:
  configMap: pharos-enrichers
  config: enrichers/enricher.yaml
  # If config is not specified allows to create configMap from hbs and files
  mappers: 
    hbs: 
      eos_v1.hbs: |
        distro: {{ .payload.Image.DistroName }}
        version: {{ .payload.Image.DistroVersion }}
        eos: {{ index .meta.eos .payload.Image.DistroName | filter "version" "matchWildcard" .payload.Image.DistroVersion | map "field" "eos" | first }}
    files:
      eos.yaml: files/eos.yaml
  uiUrl: "" # leave empty to disable UI enrichers
  #uiUrl: "http://pharos-client.pharos-client.svc.cluster.local:3000" # URL to the Pharos UI, used in enrichers to run visual enrichers.

caCertificates:
  # -- Enable CA certificates configMap
  configMapEnabled: false
  # -- Enable CA certificates in the reporter pod
  enabled: false
  # -- ConfigMap name for CA certificates, bring your own if configMapEnabled is true
  configMapName: ca-certificates
    
alerting:
  # -- Alerting configuration this basically follows the prometheus alertmanager configuration
  route:
    group_by: ["..."]
    continue: true
    receiver: default
    child_routes: []
  receivers:
    # -- list of receivers to receive alerts
    - name: "default"
    # Uncomment the following to enable alerting via jiralert, or see a complete example in values-jiralert-example.yaml
    # - name: "jira"
    #   webhook_configs:
    #     - url: "http://pharos-jiralert:9097/alert"
    #       send_resolved: true

# JIRA alerting configuration, this will install jiralert, see: https://github.com/prometheus-community/jiralert
jiralert:
  # -- Enable JIRA alerting
  enabled: false
#   extraArgs: 
#     - -hash-jira-label
#   config:
#     # File containing template definitions. Required.
#     template: jiralert.tmpl
#     # Global defaults, applied to all receivers where not explicitly overridden. Optional.
#     defaults:
#       # API access fields.
#       api_url: http://myproject.atlassian.net
#       user: username
#       # Get password from the $PASSWORD environment variable.
#       password: password
#       # Alternatively to user and password use a Personal Access Token
#       # personal_access_token: "Your Personal Access Token". See https://confluence.atlassian.com/enterprise/using-personal-access-tokens-1026032365.html
#       #personal_access_token: none
#       # The type of JIRA issue to create. Required.
#       issue_type: Vulnerability
#       # Issue priority. Optional.
#       priority: Medium
#       # Go template invocation for generating the summary. Required.
#       summary: '{{ template "jira.summary" . }}'
#       # Go template invocation for generating the description. Optional.
#       description: '{{ template "jira.description" . }}'
#       # State to transition into when reopening a closed issue. Required.
#       reopen_state: "To Do"
#       # Do not reopen issues with this resolution. Optional.
#       wont_fix_resolution: "Won't Fix"
#       # Amount of time after being closed that an issue should be reopened, after which, a new issue is created.
#       # Optional (default: always reopen)
#       reopen_duration: 0h
#       # Static label that will be added to the JIRA ticket alongisde the JIRALERT{...} or ALERT{...} label
#       # static_labels: ["custom"]
#       # Other projects are the projects to search for existing issues for the given alerts if
#       # the main project does not have it. If no issue was found in, the main projects will
#       # be used to create a new one. If the old issue is found in one of the other projects
#       # (first found is used in case of duplicates) that old project's issue will be used for
#       # alert updates instead of creating on in the main project.
#       # other_projects: []
#       # # Include ticket update as comment. Optional (default: false).
#       # update_in_comment: false

#     # Receiver definitions. At least one must be defined.
#     receivers:
#       # Must match the Alertmanager receiver name. Required.
#       - name: "jira"
#         # JIRA project to create the issue in. Required.
#         project: PHAR
#         # Copy all Prometheus labels into separate JIRA labels. Optional (default: false).
#         add_group_labels: false
#         # Include ticket update as comment too. Optional (default: false).
#         # update_in_comment: false
#         # Will be merged with the static_labels from the default map
#         # static_labels: []
#         # These fields may be different in your Jira setup
#         fields:
#           # ImageSpec
#           customfield_10060: '{{ template "jira.imagespec" . }}'
#           # Namespace
#           customfield_10061: '{{ template "jira.namespace" . }}'
#           # Digest
#           customfield_10058: '{{ template "jira.digest" . }}'
#           # ImageID
#           customfield_10059: '{{ template "jira.imageid" . }}'
#         auto_resolve:
#           state: "Done"

#   issueTemplate: |
#     {{`
#     {{ define "jira.summary" }}[{{ .Status | toUpper }}{{ if eq .Status "firing" }}:{{ .Alerts.Firing | len }}{{ end }}] {{ .GroupLabels.imagespec }} in namespace {{ .GroupLabels.namespace }} has vulnerabilities{{ end }}
#     {{ define "jira.description" }}{{ range .Alerts.Firing }}
#     h4. Labels:
#     ||Name||Value||
#     {{ range .Labels.SortedPairs -}}
#     {{ $color := "black" -}}
#     {{ if eq .Name "Critical" }}{{ $color = "purple" }}{{ end -}}
#     {{ if eq .Name "High" }}{{ $color = "red" }}{{ end -}}
#     {{ if eq .Name "Medium" }}{{ $color = "orange" }}{{ end -}}
#     {{ if eq .Name "Low" }}{{ $color = "yellow" }}{{ end -}}
#     |{{ .Name }}|{color:{{ $color }}}{{ .Value }}{color}|
#     {{ end }}
#     h4. Annotations:
#     {{ range .Annotations.SortedPairs }} - {{ .Name }} = {{ .Value }}
#     {{ end }}
#     Source: {{ .GeneratorURL }}
#     {{ end }}
#     {{ end }}

#     {{ define "jira.namespace" }}
#     {{ .GroupLabels.namespace }}
#     {{ end }}

#     {{ define "jira.imagespec" }}
#     {{ .GroupLabels.imagespec }}
#     {{ end }}

#     {{ define "jira.imageid" }}
#     {{ .GroupLabels.imageid }}
#     {{ end }}

#     {{ define "jira.digest" }}
#     {{ .GroupLabels.digest }}
#     {{ end }}
#     `}}
